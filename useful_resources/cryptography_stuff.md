## Cryptology 

It has two domains:
1. Cryptography: The science of writing with the goal of hiding the meaning of a message.

2. Cryptanalysis: The science and sometimes art of breaking cryptosystems.

Crptography is further broken down into:
1. Symmetric ciphers: 
Alice and Bob communicate over a channel. If it is insecure, Oscar can eavesdrop.
Alice encrypts her message x using a symmetric algorithm, yielding the ciphertext y. Bob
receives the ciphertext and decrypts the message.

* x is called plaintext or cleartext,
* y is called ciphertext,
* k is called the key
* set of all possible keys is called the key space.

2. Assymmetric ciphers

3. Protocols: deal with the application of cryptographic algorithms.

Cryptanalysis is further broken down into:
1. Classical 
Two types:
* Mathematical Analysis
* Brute Force attacks

2. Implementation attacks

3. Social ENgineering


### Kerckhoffs Principle:
A cryptosystem should be secure even if the attacker (Oscar) knows all details about the system, with the exception of the secret key. In particular, the system should be secure when the attacker knows the encryption and decryption algorithms.


### Types of Symmetric ciphers:
1. Substitution: substitute each letter of the alphabet with another one.
Types of attack: 
* Brute force/ Exhaustive search (treats cipher like a black box) 
* Letter frequency analysis (analyzes internal structure)
Types:
	1. Caesar / Shift:  shift every plaintext letter by a fixed number of positions in the alphabet.
	2. Affine:  multiplying the plaintext by one part of the key followed by addition of another part of the key.

2. Stream Ciphers: encrypt bits individually by adding a bit from a key stream to a plaintext bit. 
Types:
	1. Synchronous: key stream depends only on the key
	2. Asynchronous: key stream also depends on the ciphertext.
The security of stream ciphers depends on the key stream.
Randomness plays a role: TRNM (True random number generator), PRNM (pseudo random number generator), CSPRNG (Cryptographically Secure Pseudorandom Number Generators)

### One time pad (OTP):
Unconditional security: A cryptosystem is unconditionally or information-theoretically secure if it cannot be broken even with infinite computational resources.
OTP is unconditionally secure.
* the key stream s0,s1,s2,... is generated by a true random number generator
* the key stream is only known to the legitimate communicating
parties
* every key stream bit si is only used once

3. Block ciphers: encrypt an entire block of plaintext bits at a time with the same
key.  eg: DES (8 bytes) and AES (16 bytes)

### Properties of strong encryption algorithms:
1. Confusion
2. Diffusion


### DES:
A symmetric cipher. It follows an iterative algorithm. It forms a Fiestel network. It encrypts blocks of length of 64 bits with a key of size of 56 bits. 
The f function: In round i it takes the right half Ri−1 of the output of the previous round and the current round key ki as input. The output of the f-function is used as an XOR-mask for encrypting the left half input bits Li−1.

The COPOCABANA machine allows one to break the DES with average search time of less than 7 days. Thus a key size of 56 bits is too short to encrypt confidential data. THis is a brute force attack, but two analytical attacks have also been found. 

* Triple DES is three subsequent DES encryptions.

### AES 
Key size vary between 128, 192 and 256 bits, but block size is 128 bits. 
Does not use Fiestal networks, but Galois field arithmetic. 

COMPONENTS:
1. Key addition layer
2. Byte substitution layer/ S box (16 byte input fed into this)
3. Diffusion layer 
	a. ShiftRows (input permuted byte wise)
	b. MixColumn (input mixed here)

DES has bit oriented structure, AES has byte oriented structure.


### Public key cryptography

Math principles: 
* Euclidean algorithm for gcd: an extension is used to compute modular inverses (used in public key)
This is important to almost all public key schemes (already looked at affine cipher)

* Euler's Phi Function: The number of integers relatively prime to m is denoted by phi m. 

* Fermats Little theorem: a^p = a mod p

* Euler's Theorem: if gcd(a, m) = 1: a ^ phi m = 1 mod m


### RSA
Given public key (n, e) = k and plaintext x,
encryption y = e (x) = x ^e mod n
private key d 
decryption x = d (y) = y ^ d mod n

* Since an attacker has access to the public key, it must be computationally infeasible to determine the private-key d given the public-key values e and n.

*  Since x is only unique up to the size of the modulus n, we cannot encrypt more than l bits with one RSA encryption, where l is the bit length of n.

* It should be relatively easy to calculate xe mod n, i.e., to encrypt, and yd mod n, i.e., to decrypt. This means we need a method for fast exponentiation with very long numbers.

* For a given n, there should be many private-key/public-key pairs, otherwise an attacker might be able to perform a brute-force attack

* The public key e can be a short integer. The private key d needs to have the full length of the modulus. Hence, encryption can be significantly faster than decryption

* RSA relies on the integer factorization problem. 


### RSA Key Generation

1. Choose two large primes p and q.
2. Compute n = p · q
3. Compute phi (n) = (p-1) (q - 1)
4. Select public key exponent e such that gcd(e, phi(n)) = 1
5. Compute private key d such that d.e = mod phi(n)


### Hash Function properties:
1. Arbitrary message size h(x) can be applied to messages x of any size
2. Fixed output length h(x) produces a hash value z of fixed length
3. Efficiency h(x) is relatively easy to compute
4. Preimage resistance For a given output z, it is impossible to find any input x such that h(x) = z
5. Collision resistance It is computationally infeasible to find any pairs x1 not equal to x2 such that h(x1) = h(x2).

Types:
1. Dedicated: algorithms that are specifically designed to serve as hash functions
2. Block cipher-based hash functions: use block ciphers such as AES to construct hash functions

### Merkle Damgard construction: 

hash functions can process an arbitrary-length message and produce a fixed-length output. This is achieved by segmenting the input into a series of blocks of equal size. These blocks are processed sequentially by the hash function, which has a compression function at its heart. The hash value of the input message is then defined as the output of the last iteration of the compression function.

### MAC: Message Authentication Codes
It is a cryptographic checksum or a keyed hash function.

* It generates a cryptographically secure authentication tag for a given message
* MACs provide message integrity: Any manipulations of a message during transit will be detected by the receiver.
* Message authentication The receiving party is assured of the origin of the message.

The basic idea behind all hash-based MACs is that the key is hashed together with the message.

Types:

1. Secret prefix MAC:
m = MAC(x) = h(k | x)

2. Secret suffix MAC:
m = MAC(x) = h(x | k)

